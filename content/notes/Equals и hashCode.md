---
aliases: hashCode, equals, хэшкод
tags: Java/ООП
---
## Equals
Equals – это метод, определенный в Object, который служит для сравнения СОСТОЯНИЯ объектов.
- При сравнении объектов при помощи == сравниваются ссылки
- При сравнении по equals() сравниваются состояния объектов

При переопределении equals() обязательно нужно переопределить метод hashCode().
Равные объекты должны возвращать одинаковые хэш коды.
[[Equals|Подробнее...]]
## Hash code

[[HashCode]]

## Вопросы

### Для чего нужен метод hashCode?
**Метод hashCode() – это ПРИКИДКА**: объекты возможно равны? Если ок, то вызываем equals() для ТОЧНОГО сравнения. Разные коды, следовательно содержание разное.

### Какие поля следует использовать при подсчете hashCode()?
Выбирать поля, которые с большой долей вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

### Могут ли у разных объектов быть одинаковые hashCode?
Да. Ситуация, когда у разных объектов одинаковые хэшкоды, называется **коллизией**.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш-кода.

### Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть.

### Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y
Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.

Алгоритм доступно и близко к практике (работа с данными) https://youtu.be/lWnzRILIEZ0

## Контракт между equals и hashCode
![[контракт между hashCode и equals.png]]

### Что будет, если переопределить equals() не переопределяя hashCode()?
Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map, возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.
![[equals и hashСode вместе.png]]
## Источники:
- [Контракты Java equals() и hashCode()](https://www.baeldung.com/java-equals-hashcode-contracts)
- [Руководство по hashCode() в Java](https://www.baeldung.com/java-hashcode#handling-hash-collisions)