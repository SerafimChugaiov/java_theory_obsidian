---
tags:
  - Java/ОсновыЯзыка
---
### @Deprecated

**Retention:** Runtime;
**Target:** CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE. 

Данная аннотация указывает на методы, классы или переменные, которые является **"устаревшими"** и могут быть убраны в последующих версиях продукта. 

С данной аннотацией обычно сталкиваются те, кто читает документацию каких-либо API, либо той же стандартной библиотеки Java. Иногда эту аннотацию игнорируют, т.к. она не вызывает никаких ошибок и в принципе сама по себе сильно жить не мешает. 

Однако главный посыл, который несет в себе данная аннотация – **"мы придумали более удобный метод реализации данного функционала, используй его, не используй старый"** - ну, либо же - **"мы переименовали функцию, а это так, для легаси оставили..."** (что тоже в общем-то неплохо). Короче говоря, если видите **@Deprecated** - лучше стараться не использовать то, над чем она висит, если в этом нет прям крайней необходимости и, возможно, стоит перечитать документацию, чтобы понять **каким образом теперь реализуется задача, выполняемая устаревшим элементом**. 

>[!info]
>Например вместо использований new `Date().getYear()` рекомендуется использовать `Calendar.getInstance().get(Calendar.YEAR)`.

### @Override

**Retention:** SOURCE;
**Target:** METHOD;

Данная аннотация показывает, что метод над котором она прописана **наследован у родительского класса.** 

Первая аннотация с которой сталкивался каждый начинающий Java-программист, при использовании IDE, которая настойчиво пихает эти **@Override**. Зачастую учителя с ютуба рекомендуют либо: "сотрите чтобы не мешало", либо: "оставьте не задумываясь зачем оно здесь". На самом деле аннотация более чем полезна: она не только позволяет понять какие методы были определены в этом классе впервые, а **какие уже есть у родителей** (что бесспорно повышает читаемость вашего кода), но также данная аннотация служит **"самопроверкой"**, что вы не ошиблись при определении перегружаемой функции.
### @SuppressWarnings

**Retention:** SOURCE;
**Target:** TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE;

Данная аннотация **отключает вывод предупреждений компилятора**, которые касаются элемента над которым она указана. Является SOURCE аннотацией указываемой над полями, методами, классами.

Предупреждения делятся на непроверенные (unchecked) и устаревшие (deprecation). Первые возникают при использовании устаревшего кода, написанного до дженериков, вторые - при использовании кода, помеченного аннотацией @Deprecated.

Можно подавить как одну категорию, так и обе сразу:
```java
@SuppressWarnings({"unchecked", "deprecation"})
```

### @SafeVarargs

**Retention:** CLASS  
**Target:** CONSTRUCTOR, METHOD

Аннотация сообщает компилятору, что метод или конструктор с varargs-параметрами использует их безопасно, и подавляет предупреждения `unchecked`.

Применяется только к `static`, `final` методам и конструкторам, чтобы избежать переопределения и ошибок типов.

**Важно:** использовать аннотацию стоит **только если вы точно уверены**, что нет небезопасных операций с массивом varargs.

**Пример неправильного использования:**
```java
@SafeVarargs // На самом деле не безопасно!
static void m(List<String>... stringLists) {
    Object[] array = stringLists;
    List<Integer> tmpList = Arrays.asList(42);
    array[0] = tmpList; // Ошибка всплывёт позже
    String s = stringLists[0].get(0); // ClassCastException
}
```

>[!info]
>Если не уверены — лучше не используйте. Ошибка может проявиться только в рантайме(во время выполнения программы).

### @FunctionalInterface

**Retention:** CLASS  
**Target:** TYPE

Аннотация помечает интерфейс как **функциональный**, то есть такой, у которого **есть только один абстрактный метод**. Такие интерфейсы можно использовать в лямбда-выражениях.

**Пример:**
```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```
Если попытаться добавить второй абстрактный метод — компилятор выдаст ошибку. Это помогает избежать случайных изменений и делает интерфейс явно предназначенным для функционального программирования.

>[!info]
>Кстати, **@FunctionalInterface** — одна из _мета-аннотаций_, применимых к другим аннотациям. Такие аннотации находятся в пакете `java.lang.annotation`.