---
aliases:
  - hashCode
  - хэшкод
tags:
  - Java/ООП
---

**Хеширование**  —  фундаментальная концепция компьютерной науки.

В Java эффективные алгоритмы хеширования лежат в основе некоторых из самых популярных коллекций, таких как _HashMap_ и _HashSet_.

Мы же сосредоточимся на том, как работает _hashCode()_ , как он применяется в коллекциях и как его правильно реализовать.

**Метод .hashCode _()_ возвращает целое число, представляющее текущий экземпляр класса** . Мы должны вычислять это значение в соответствии с определением равенства класса.

## Использование _hashCode()_ в структурах данных

Простейшие операции с коллекциями могут оказаться неэффективными в определенных ситуациях.

Для иллюстрации это запускает линейный поиск, который крайне неэффективен для огромных списков:

```java
List<String> words = Arrays.asList("Welcome", "to", "Baeldung");
if (words.contains("Baeldung")) {
    System.out.println("Baeldung is in the list");
}
```
Java предоставляет ряд структур данных для решения этой проблемы. Например, несколько реализаций интерфейса _Map являются_ [хэш-таблицами](https://www.baeldung.com/cs/hash-tables) .

При использовании хэш-таблицы **эти коллекции вычисляют хэш-значение для заданного ключа с помощью метода _hashCode()_ .** Затем они используют это значение внутри для хранения данных, чтобы операции доступа были намного эффективнее.

## Понимание того, как работает _hashCode()_

Проще говоря, _hashCode()_ возвращает целочисленное значение, сгенерированное алгоритмом хеширования.

Объекты, которые равны (согласно их _equals()_ ), должны возвращать один и тот же хэш-код. **Разные объекты не обязаны возвращать разные хэш-коды.**

Все три критерия в контракте . _hashCode()_ каким-либо образом упоминают метод . _equals()_ **:**
- _внутренняя согласованность_ : значение _hashCode()_ может измениться только в том случае, если  изменится  свойство, находящееся в  _equals()_
- _Равенство согласованности_ : объекты, которые равны друг другу, должны возвращать один и тот же хэш-код
- _столкновения_ : неравные объекты могут иметь одинаковый хэш-код
![[Переопределение hashCode.png|600]]

>[!info]
>«Насколько это разумно и практично, метод _hashCode(),_ определенный классом _Object_ , возвращает отдельные целые числа для отдельных объектов. (Обычно это реализуется путем преобразования внутреннего адреса объекта в целое число, но этот метод реализации не требуется языком программирования JavaTM.)»

## Наивная реализация _hashCode()_

Наивная реализация _hashCode()_ , которая полностью соответствует вышеуказанному контракту, на самом деле довольно проста.

Чтобы продемонстрировать это, мы определим пример класса _User_ , который переопределяет реализацию метода по умолчанию:
```java
public class User {

    private long id;
    private String name;
    private String email;

    // standard getters/setters/constructors
        
    @Override
    public int hashCode() {
        return 1;
    }
        
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null) return false;
        if (this.getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id 
          && (name.equals(user.name) 
          && email.equals(user.email));
    }
    
    // getters and setters here
}
```

Класс _User_ предоставляет пользовательские реализации для _equals()_ и _hashCode()_ , которые полностью соответствуют соответствующим контрактам. Более того, нет ничего противозаконного в том, чтобы _hashCode()_ возвращал любое фиксированное значение.

**Однако такая реализация практически сводит функциональность хеш-таблиц к нулю, поскольку каждый объект будет храниться в одном и том же контейнере.**

В этом контексте поиск в хэш-таблице выполняется линейно и не дает нам никаких реальных преимуществ. Подробнее об этом мы поговорим в разделе: **Обработка коллизий хэшей**

## Улучшение реализации _hashCode()_

Давайте улучшим текущую реализацию _hashCode()_ , включив все поля класса _User_ , чтобы он мог выдавать разные результаты для неравных объектов:

```java
@Override
public int hashCode() {
    return (int) id * name.hashCode() * email.hashCode();
}
```

Этот базовый алгоритм хеширования определенно намного лучше предыдущего. Это потому, что он вычисляет хеш-код объекта, просто умножая хеш-коды полей _имени_ и _электронной почты_ и _идентификатора_ .

В целом можно сказать, что это разумная реализация _hashCode()_ , если только мы сохраним согласованную с ней реализацию _equals() ._

## Стандартные реализации _hashCode()_

Чем лучше алгоритм хеширования, который мы используем для вычисления хеш-кодов, тем выше производительность хеш-таблиц.

Давайте рассмотрим «стандартную» реализацию, которая использует два простых числа для добавления еще большей уникальности вычисляемым хеш-кодам:
```java
@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    return hash;
}
```

Хотя нам нужно понимать роли, которые играют методы _hashCode()_ и _equals()_ , нам не нужно реализовывать их с нуля каждый раз. Это потому, что большинство IDE могут генерировать пользовательские реализации _hashCode()_ и _equals()_ . И начиная с Java 7, у нас есть вспомогательный метод _Objects.hash()_ для удобного хеширования:

```java
Objects.hash(name, email)
```

IntelliJ IDEA генерирует следующую реализацию:

```java
@Override
public int hashCode() {
    int result = (int) (id ^ (id >>> 32));
    result = 31 * result + name.hashCode();
    result = 31 * result + email.hashCode();
    return result;
}
```

## Обработка коллизий хэшей

Внутреннее поведение хэш-таблиц поднимает важный аспект этих структур данных: даже при эффективном алгоритме хэширования два или более объектов могут иметь одинаковый хэш-код, даже если они не равны. Таким образом, их хэш-коды будут указывать на один и тот же контейнер, даже если у них будут разные ключи хэш-таблицы.

Эта ситуация обычно известна как коллизия хеша, и существуют различные методы ее обработки, каждый из которых имеет свои плюсы и минусы. _HashMap_ в Java использует отдельный метод цепочки для обработки коллизий:

**«Когда два или более объектов указывают на один и тот же контейнер, они просто сохраняются в связанном списке. В таком случае хэш-таблица представляет собой массив связанных списков, и каждый объект с одинаковым хешем добавляется в связанный список по индексу контейнера в массиве.**

**В худшем случае к нескольким контейнерам будет привязан связанный список, и извлечение объекта из списка будет выполняться линейно».**

Методологии коллизий хешей наглядно показывают, почему так важно эффективно реализовать _hashCode()_ _._