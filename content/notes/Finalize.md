---
tags: Java/ПодКапотом
---
Метод придуман для минимизации риска утечки внешних ресурсов. _Может_ быть вызван виртуальной машиной при сборке мусора (добавляя при этом для нее избыточную нагрузку). Это **не** то же самое, что деструктор в C++.

Есть только гарантии, что метод не будет вызван пока есть ссылки на объект, и что не будет вызван больше одного раза. Даже то, что вызов будет вообще – не факт. Исполнять будет неизвестно какой, но не синхронизированный поток. Исключения проигнорируются.

С давних пор использовать финализаторы [не рекомендуется](https://stackoverflow.com/q/158174/5521491) ([Effective Java Item 7](https://books.google.ru/books?id=ka2VUBqHiWkC&lpg=PA27&ots=y_HfPet_N3&dq=effective%20java%20item%207&hl=ru&pg=PA27#v=onepage&q&f=false)), а с Java 9 этот метод помечен как deprecated. Вместо финализатора всегда стоит воспользоваться `try/finally`, `try-with-resource` или более специализированными классами пакета `java.lang.ref`.

## зачем нужен Finalize?
Этот метод вызывается Java-машиной у объекта перед тем, как объект будет уничтожен. Фактически этот метод – противоположность конструктору. В нем можно освобождать ресурсы, используемые объектом.

— Этот метод есть у класса Object и, следовательно, есть в каждом классе (все классы в Java считаются унаследованными от класса Object и содержат копию его методов). Ты можешь просто написать в твоём классе такой же метод, и он будет вызываться перед уничтожением объектов этого класса.

```java
class Cat {
	String name; 
	
	Cat(String name) {
		this.name = name; 
	}
	
	protected void finalize() throws Throwable {
	
	 System.out.println(name + " destroyed"); 
	 
	 } 
}
```
