---
tags: Java/Исключения
---
![[Исключения. Виды исключений.png]]

В Java исключения организованы в иерархическую структуру классов. Все исключения наследуются от класса `Throwable`, который является корневым классом иерархии исключений. Класс `Throwable` имеет два основных подкласса: `Error` и `Exception`.
## Error

Представляет серьезные ошибки, с которыми обычно невозможно справиться во время выполнения программы. Например, `OutOfMemoryError` возникает, когда в памяти не хватает места для создания новых объектов.
## Exception

Представляет ошибки, которые возникают во время выполнения программы, но обычно могут быть обработаны или учтены.  Цель каждого выброшенного исключения — быть захваченным тем блоком `catch`, который знает, что нужно сделать в этой ситуации.

Когда какой-то метод не может выполнить свою работу по какой-то причине, он сразу должен уведомить об этом вызывающий метод, выбрасывая исключение соответствующего типа. 

Другими словами, если какая-то переменная оказалась равна `null`, метод выкинет `NullPointerException`, если в метод передали неверные аргументы — выкинет `InvalidArgumentException`, если в методе случайно было деление на ноль — `ArithmeticException`.

Исключения в этой категории делятся на два подвида: проверяемые исключения (`checked exceptions`) и непроверяемые исключения (`unchecked exceptions`).

## RuntimeException

`RuntimeException` — это разновидность (подмножество) исключений `Exception`. Можно даже сказать, что `RuntimeException` — это облегченная версия обычных исключений (`Exception`): на такие исключения налагается меньше требований и ограничений

Об отличии `Exception` и `RuntimeException` вы узнаете дальше
## Типы исключений в Java: Проверяемые и непроверяемые: `throws`, checked exceptions

Все исключения в Java делятся на 2 категории — проверяемые (checked) и непроверяемые (unchecked).
![[Исключения. Схема №4.png]]

Все исключения, унаследованные от классов `RuntimeException` и `Error`, считаются unchecked-исключениями, все остальные — checked-исключениями.

**Проверяемые исключения** (checked exceptions) — это исключения, которые должны быть обработаны или объявлены в сигнатуре метода с помощью ключевого слова `throws`. Компилятор Java проверяет, чтобы программисты обработали или передали дальше все проверяемые исключения. 

Примеры проверяемых исключений — это `IOException`, `SQLException`, `ClassNotFoundException` и другие. Например, `IOException` — это проверяемое исключение, которое может возникнуть при работе с файлами. 

**Непроверяемые исключения** (unchecked exceptions) — это исключения, которые не требуют явной обработки или объявления в сигнатуре метода. Обычно они являются результатом ошибок программирования или непредвиденных условий, таких как `NullPointerException`, `ArrayIndexOutOfBoundsException` и другие. Например, `NullPointerException` — это непроверяемое исключение, которое возникает при обращении к объекту, который имеет значение `null`.

Непроверяемые исключения наследуются от класса `RuntimeException` или его подклассов. Компилятор Java не требует обязательной обработки или объявления непроверяемых исключений, поэтому их обработка остается на усмотрение программиста.

### В чем же основное отличие checked-исключений от unchecked?

К checked-исключениям есть дополнительные требования. Звучат они примерно так.

**Требование 1**

Если метод выбрасывает checked-исключение, он должен содержать тип этого исключения в своем заголовке (сигнатуре метода). Чтобы все методы, которые вызывают данный метод, знали о том, что в нем может возникнуть такое «важное исключение».

Указывать checked-исключения надо после параметров метода после ключевого слова `throws` (не путать со `throw`). Выглядит это примерно так:

```java
тип метод (параметры) throws исключение
```

Пример:

![[Исключения. Таблица.png]]

В примере справа наш код выкидывает **unchecked-исключение** — никаких дополнительных действий не нужно. В примере слева метод выкидывает **checked-исключение**, поэтому в сигнатуру метода добавили ключевое слово `throws` и указали тип исключения.

Если метод планирует выкидывать несколько checked-исключений, все их нужно указать после ключевого слова `throws` через запятую. Порядок неважен. Пример:

```java
public void calculate(int n) throws Exception, IOException
{
   if (n == 0)
      throw new Exception("n равно нулю!");
   if (n == 1)
      throw new IOException("n равно единице");
}
```

**Требование 2**

Если вы вызываете метод, у которого в сигнатуре прописаны checked-исключения, то вы не можете проигнорировать этот факт.

Вы должны либо перехватить все эти исключения, добавив блоки `catch` для каждого из них, либо добавить их в `throws` своего метода.

Мы как бы говорим себе: эти исключения настолько важные, что мы обязательно должны их перехватить. А если мы не знаем, как их перехватить, мы должны уведомить тех, кто будет вызывать наш метод, что в нем могут возникнуть такие исключения.

**Пример:**
Представим, что мы пишем метод, который должен создать мир, населенный людьми. Начальное количество человек передается в качестве параметра. Тогда мы должны добавить исключения, если людей слишком мало.
![[Исключения. Таблица №2.png]]

##### Вызов этого метода можно обработать 3 способами:

**1. Не перехватываем возникающие исключения**
Чаще всего это делается в случае, когда в методе не известно, как правильно обработать эту ситуацию.
![[Исключения. Таблица №3.png]]

**2. Перехватывать часть исключений**
Обрабатываем понятные ошибки, непонятные — прокидываем в вызывающий метод. Для этого нужно добавить их название в throws:
![[Исключения. Таблица №4.png]]

**3. Перехватываем все исключения**
Если метод не прокидывает исключения вызывающему методу, вызывающий метод всегда будет уверен, что все выполнилось хорошо. И не сможет предпринять никаких действий, чтобы исправить ситуацию.
![[Исключения. Таблица №5.png]]
## Обертывание исключений

Checked-исключения казались классной вещью в теории и **оказались полным разочарованием** на практике.

Допустим, у вас в проекте есть суперпопулярный метод, который вызывается из сотен мест программы. И вы решили добавить в него новое **checked-исключение**. И вполне может оказаться, что это checked-исключение действительно такое важное и особенное, что только метод `main()` знает, что делать в случае захвата этого исключения.

Поэтому вам придется добавить checked-исключение в `throws` всех методов, которые вызывают ваш суперпопулярный метод. А также в `throws` всех методов, которые вызывают те методы. И в методы, которые вызывает те методы.

В результате у вас в `throws` у половины методов проекта будет добавлено новое checked-исключение. А потом окажется, что у вас проект покрыт тестами, и тесты не компилируются. И вам придется править throws еще и в тестах.

А потом весь ваш код (изменения в сотнях файлов) должны будут ревьюить другие программисты. И тут мы задаем себе вопрос: а ради чего мы вносили в проект дохреналион изменений? День(дни?) работы, сломанные тесты, и все ради добавления одного checked-исключения?

А ведь есть еще проблемы с наследованием и переопределением методов. Проблем от checked-исключений гораздо больше, чем пользы. В общем, сейчас мало кто их любит и мало кто использует.

Однако все еще много кода (в том числе и код стандартных библиотек Java) содержат эти самые checked-исключения. И что же с ними делать? Игнорировать нельзя, обрабатывать – неизвестно как.

Java-программисты предложили **«заворачивать»** checked-исключения внутрь `RuntimeException`. Другими словами, перехватывать все checked-исключения, создавать вместо них unchecked-исключения (например, `RuntimeException`) и выбрасывать уже их. Выглядит это все примерно так:

```java
try
{
   код, где может возникнуть checked-исключение
}
catch(Exception exp)
{
   throw new RuntimeException(exp);
}
```

Не сильно красивое решение, но ничего криминального: исключение просто положили внутрь исключения `RuntimeException`.

При желании его можно оттуда легко достать. Пример:
![[Исключения. Таблица №6.png]]
## Множественный перехват исключений

Программисты очень не любят дублирование кода. Даже придумали такой принцип разработки — DRY: Don’t Repeat Yourself. Однако при обработке исключений часто возникают ситуации, когда после блока `try` следует несколько блоков `catch` с одинаковым кодом.

Или может быть, например, 3 `catch`-блока с одним кодом и еще 2 `catch`-блока с другим. Стандартная в общем-то ситуация, когда у вас в проекте ответственно относятся к обработке исключений.

Начиная с 7-й версии, в язык Java добавили возможность указать несколько типов исключений в одном блоке `catch`. Выглядит это примерно так:

```java
try
{
   код, где может возникнуть ошибка
}
catch(ТипИсключения1 | ТипИсключения2 | ТипИсключения3 имя)
{
   код обработки исключений
}
```

Блоков `catch` может быть сколько угодно. Однако в одном блоке `catch` нельзя указать исключения, которые наследуются друг от друга. Т.е. нельзя написать catch (`Exception` | `RuntimeException` e), т.к. класс `RuntimeException` унаследован от `Exception`.

## Stack Trace
[[Stack Trace]]

### Что такое OutOfMemoryError?
`OutOfMemoryError` — это **ошибка в Java**, которая возникает, когда **JVM не может выделить достаточно памяти** для создания объектов. Чаще всего это связано с **переполнением кучи (Heap)** из-за большого количества данных, **утечек памяти**, бесконечных циклов или **неэффективной работы с ресурсами**. Это **не исключение, а ошибка уровня `Error`**, и она сигнализирует о **серьёзной проблеме**, требующей анализа и оптимизации кода.

Эта ошибка решается так: нужно **сократить количество создаваемых объектов**, **освобождать память от ненужных данных**, можно **увеличить объём памяти, доступной JVM** (например, с помощью параметра `-Xmx512m`), а также использовать **специальные программы** — такие как **VisualVM или JProfiler** — чтобы **посмотреть, что именно «съедает» память**. Всё это поможет найти и устранить причину.
