---
tags:
  - Java/ОсновыЯзыка
---
### @Retention

**Retention:** RUNTIME;
**Target:** ANNOTATION_TYPE;

Указывает, сколько хранится отмеченная аннотация:

- `RetentionPolicy.SOURCE`. Отмеченная аннотация сохраняется только на уровне исходного кода и игнорируется компилятором.
- `RetentionPolicy.CLASS`. Сохраняется компилятором во время компиляции, но игнорируется JVM.
- `RetentionPolicy.RUNTIME`. Сохраняется JVM для использования во время выполнения программы.

То есть, данная аннотация задает **"тип хранения"** аннотации над которой она указана. Да эта аннотация используется даже для самой себя... магия да и только.
### @Documented

**Retention:** RUNTIME  
**Target:** ANNOTATION_TYPE

Аннотация применяется **только к другим аннотациям** (мета-аннотация) и указывает, что эти аннотации должны попадать в **Javadoc**.

По умолчанию аннотации **не отображаются** в документации, и если вы хотите, чтобы ваша аннотация была видна другим разработчикам — пометьте её `@Documented`.

**Пример:**
```java
@Documented
public @interface MyAnnotation {
    String value();
}
```

Теперь `@MyAnnotation` будет отображаться в сгенерированном Javadoc.\
### @Target

**Retention:** RUNTIME  
**Target:** ANNOTATION_TYPE

Аннотация **@Target** указывается **над другими аннотациями** и задаёт, к **каким элементам кода** можно применять эту аннотацию.

Это своего рода _ограничитель_, чтобы аннотацию случайно не повесили "куда попало".

Основные значения `ElementType`:

- `ANNOTATION_TYPE` — к другой аннотации
    
- `CONSTRUCTOR` — к конструктору
    
- `FIELD` — к полю класса
    
- `LOCAL_VARIABLE` — к локальной переменной
    
- `METHOD` — к методу
    
- `PARAMETER` — к параметру метода
    
- `TYPE` — ко всему классу, интерфейсу, enum или record

**Пример:**
```java
@Target(ElementType.METHOD)
public @interface LogExecutionTime {
}
```

Теперь `@LogExecutionTime` можно использовать **только над методами**.

Если нужно разрешить **несколько типов**, можно указать массив:
```java
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface Trackable {
}
```
### @Inherited

**Retention:** RUNTIME  
**Target:** TYPE

Аннотация, применимая только к другим аннотациям. Позволяет указать, что **аннотация будет автоматически "унаследована" дочерним классом**, если она применена к родительскому.

По умолчанию аннотации **не наследуются** — если вы пометите класс аннотацией, то его подкласс ничего об этом знать не будет. Но если у аннотации есть `@Inherited`, и она применена к базовому классу, то при работе с Reflection она будет видна и в дочернем классе.

Это полезно, например, в фреймворках (Spring, JPA и т.д.), где поведение аннотаций важно и на уровне наследования.

**Пример:**
```java
@Inherited
@interface Info {
    String value();
}

@Info("Базовый класс")
class Parent {}

class Child extends Parent {}
```

Если вызвать `Child.class.getAnnotation(Info.class)`, то результатом будет `@Info("Базовый класс")`.

Однако! Это работает **только для классов** (`ElementType.TYPE`) и **только при запросе через Reflection**. Если аннотация стоит на методе — она не наследуется.
### @Repeatable

**Retention:** RUNTIME  
**Target:** ANNOTATION_TYPE

Данная аннотация делает **другую аннотацию "повторяемой"** — то есть её можно указывать **несколько раз над одним и тем же элементом** (например, над классом или методом).

По умолчанию в Java одна и та же аннотация может быть указана только один раз. `@Repeatable` позволяет это обойти.

Чтобы это работало, нужно:

1. Создать обычную аннотацию (например, `@Tag`)
    
2. Создать обёртку-контейнер (например, `@Tags`)
    
3. Пометить `@Tag` как `@Repeatable(Tags.class)`

**Пример 1:**
```java
@Repeatable(Tags.class)
@interface Tag {
    String value();
}

@interface Tags {
    Tag[] value();
}

@Tag("java")
@Tag("backend")
public class MyClass {}
```

В этом примере `MyClass` имеет **две аннотации `@Tag`**, и это работает благодаря `@Repeatable`.
>[!Info]
>Всё это удобно, когда нужно передать **несколько значений одной аннотации**, но в виде отдельных записей — например, при указании ролей, меток, стратегий и т.д.
**Пример 2:**
Допустим, вам надо написать аннотацию, запускающую метод в заданное время или по определенному расписанию. В примере созданная аннотация `@Schedule` будет запускать метод каждый последний день месяца и каждую пятницу в 23:00.

```java
	@Schedule(dayOfMonth="last")
	@Schedule(dayOfWeek="Fri", hour="23")
	public void doPeriodicCleanup() { 
		... 
	}
```