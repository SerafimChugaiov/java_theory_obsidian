---
tags:
  - Java/ОсновыЯзыка
aliases:
  - String
  - char
---
Строка относится к ссылочному типу данных.

Для создания новой строки мы можем использовать один из конструкторов класса String, либо напрямую присвоить строку в двойных кавычках:
```Java
public class Main {  
    public static void main(String[] args) {  
  
        String str1 = "Java";  
        String str2 = new String(); // пустая строка  
        String str3 = new String(new char[]{'h', 'e', 'l', 'l', 'o'});  
        String str4 = new String(new char[]{'w', 'e', 'l', 'c'}, 0, 3);//1 -начальный индекс, 3 -кол-во символов  
  
        System.out.println(str1); // Java  
        System.out.println(str2); //  
        System.out.println(str3); // hello  
        System.out.println(str4); // wel  
    }  
}

System.out.println(str3+" "+str1); // объединение строк "hello Java"
```
## Как реализована неизменяемость строк?

-
    Приватное поле `value`: В классе `String` есть private поле `value`, которое является массивом символов (`char[]`), содержащим фактическое значение строки. Это поле помечено как `final`, что означает, что оно не может быть изменено после инициализации.

- Конструктор: Класс `String` имеет несколько конструкторов, которые инициализируют значение `value`. Когда вы создаете новый объект `String`, конструктор копирует переданную строку или массив символов, чтобы создать новый массив `value`.

- Отсутствие public методов для изменения значения: В классе `String` отсутствуют публичные методы, которые позволяют изменять значение `value`. Методы класса `String`, такие как `concat()`, `substring()`, `replace()` и другие, вместо этого создают и возвращают новые объекты `String` с измененными значениями, не затрагивая исходный объект `String`.

## Основные методы класса String
[[Методы класса String]]
## Пул строк
[[String Pool]]
## Про stack и heap память в Java
[[Стек и куча в Java]]

## StringBuilder и StringBuffer
[[StringBuilder и StringBuffer]]

## Регулярные выражения Regex
[[Regex]]

## Нюансы String
### Почему String неизменяемый и финализированный класс?
Безопасность и String pool – это основные причины неизменяемости String в Java.

Безопасность объекта неизменяемого класса String обусловлена такими фактами:
- вы можете передавать строку между потоками и не беспокоиться что она будет изменена
- нет проблем с синхронизацией (не нужно синхронизировать операции со String)
- отсутствие утечек памяти
- в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. Неизменяемость позволяет избежать проблем с доступом.
- возможность кэшировать hash code
String pool позволяет экономить память и НЕ создавать новые объекты для каждой повторяющийся строки. В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.
### Почему массив символов лучше строки для хранения пароля?
Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, **НО объект остается доступным в памяти** некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто- либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.

Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности.

Однако, стоит отметить, что массив символов не может быть использован везде, где используются строки. Также необходимо учитывать, что использование массива символов для хранения паролей не является панацеей и не обеспечивает полной безопасности. Безопасность приложения зависит от многих факторов, таких как криптографические методы шифрования, защита данных при передаче, хранение паролей в безопасном виде и другие меры защиты.
### Почему строка является популярным ключом в HashMap
У изменяемых объектов хэшкод изначально равен нулю и он таков до тех пор, пока мы не вызвали метод hash(), тогда и генерируется хэш-значение – в момент получения кода.

Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова.

Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.
### Почему не рекомендуется изменять строки в цикле?
Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать новую строку.
Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – StringBuffer и StringBuilder.

### Можно ли использовать строки в конструкции switch
Java 7 расширяет возможности оператора swich для использования строк, ранние версии Java не поддерживают этого.

Если вы реализуете условный поток для строк, вы можете использовать условия if-else и вы можете использовать оператор switch, если используете Java 7 или поздние версии.

Ключевые моменты использования switch для строк в Java. - использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else
- строки в switch чувствительны к регистру (см. пример)
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во
избежание NullPointerException
- согласно документации Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else - убедитесь, что это будет использоваться с Java 7 или поздней версии, иначе получите Exception
### Как сравнить две строки в Java и/или отсортировать их?

Для сравнения строк в Java можно использовать методы equals() и compareTo().

Метод equals() сравнивает содержимое двух строк и возвращает значение true, если они равны, и false - в противном случае. 

**Например:**
```java
String str1 = "Hello";String str2 = "hello";if (str1.equals(str2)) {    System.out.println("Строки равны");} else {    System.out.println("Строки не равны");}
```

**Результат выполнения программы:** `Строки не равны`

Метод compareTo() сравнивает две строки лексикографически и возвращает целое число, которое показывает, какая из строк больше или меньше. Если результат сравнения равен 0, это значит, что строки равны. Например:
```java
String str1 = "Hello";String str2 = "World";int result = str1.compareTo(str2);if (result == 0) {    System.out.println("Строки равны");} else if (result < 0) {    System.out.println("Строка str1 меньше строки str2");} else {    System.out.println("Строка str1 больше строки str2");}
```

**Результат выполнения программы:** `Строка str1 меньше строки str2`

Для **сортировки** массива строк в Java можно использовать метод Arrays.sort(). Например:
```java
String[] arr = {"apple", "banana", "orange", "pear"};Arrays.sort(arr); // сортировка в алфавитном порядкеfor (String s : arr) {    System.out.println(s);}
```

**Результат выполнения программы:**
```java
apple
banana
orange
pear
```

>[!Info]
>Обратите внимание, что метод sort() сортирует массив строк в алфавитном порядке по умолчанию. Если нужна другая сортировка, например, по длине строк, можно использовать свой компаратор и передать его как дополнительный аргумент методу sort().

### Предложите алгоритм преобразования строки в символ. Напишите соответствующий код.

Для преобразования строки в символ можно использовать метод charAt() класса String.

**Алгоритм:**
- Создать строку str.
- Получить длину строки length.
- Если length равен 0, вернуть null.
- Если length больше 1, вывести сообщение об ошибке и вернуть null.
- Получить символ из строки с помощью метода charAt().
- Вернуть полученный символ.

Пример кода на Java:
```
public static Character stringToChar(String str) {    int length = str.length();    if (length == 0) {        return null;    }    if (length > 1) {        System.out.println("Ошибка: в строке должен быть только один символ.");        return null;    }    return str.charAt(0);}
```

Пример использования:
```
String str = "H";Character ch = stringToChar(str);if (ch != null) {    System.out.println("Символ: " + ch);} else {    System.out.println("Ошибка!");}
```

**Результат выполнения программы:** `Символ: H`
### Как превратить строку в массив байтов и обратно? Напишите соответствующий код.

В Java для преобразования строки в массив байтов можно использовать метод getBytes() из класса String. Для обратного преобразования массива байтов в строку можно использовать конструктор String(byte[]). **Вот пример кода:**
```java
// преобразование строки в массив байтов
String myString = "Hello, world!";byte[] myBytes = myString.getBytes();System.out.println(Arrays.toString(myBytes));

// обратное преобразование массива байтов в строку
String myStringBack = new String(myBytes);System.out.println(myStringBack);
```

В этом примере мы создаем строку "Hello, world!", затем преобразуем ее в массив байтов с помощью метода getBytes(). Мы выводим этот массив байтов на экран, чтобы убедиться, что он был создан правильно.

Затем мы обратно преобразуем массив байтов в строку с помощью конструктора String(byte[]), и выводим эту строку на экран, чтобы убедиться, что она равна исходной строке.