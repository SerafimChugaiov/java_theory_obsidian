---
tags: Java/ОсновыЯзыка
---
## Циклы
- while с предусловием
	`while (condition){}`
- do while с постусловием
``` java
do {} 
	while(condition)
```
- for (объявление временной переменной, условие, инкремент переменной)
	- break - прерывает цикл и переносит каретку на следующую строку после цикла
	- continue - досрочно завершает текущую итерацию
```java
for (int i = 0; i < var; i++){}
```
foreach в Java
```java
for (type itVar : array) {
Блок операторов; 
}
```
Где `type` — тип итерационной переменной (совпадает с типом данных в массиве!), `itVar` — её имя, `array` — массив (тут также может быть другая структура данных, какая-нибудь коллекция, например, `ArrayList`), то есть объект, по которому выполняется цикл. Как вы видите, счётчик в такой конструкции не применяется, итерационная переменная перебирает элементы массива или коллекции, а не значения индекса.

Пример:
```java
int[] arr = {1,2,3,4,5};  
for (int num : arr) {  
    System.out.print(num+ ", ");  
}
```

### Рекурсия
**Рекурсия** — это когда метод вызывает сам себя, чтобы решить задачу частями. Она делает то же, что и циклы, только другим способом. Например, можно пройтись по списку чисел с помощью `for`, а можно — рекурсивно, перебирая элементы один за другим. Главное в рекурсии — не забыть базовый случай, чтобы остановить вызовы. На собеседовании можно сказать что рекурсия — это альтернатива циклам, особенно удобная для задач, где решение можно разбить на одинаковые шаги, как в подсчёте суммы чисел или поиске файла в папках.

**Преимущества**
- естественность (натуральность) выражения сложных, на первый взгляд, алгоритмов.
- рекурсивный алгоритм более читабелен в сравнении с итерационным;
- для многих распространенных задач рекурсию более легче реализовать чем итерацию. Рекурсия хорошо подходит для реализации алгоритмов обхода списков, деревьев, графов и т.д.

**Недостатки рекурсии**
- по сравнению с итерацией многократный вызов рекурсивной функции работает дольше. Это связано с тем, что при вызове рекурсивного метода его параметры копируются в стек. Также запоминаются временные значения локальных внутренних переменных. При завершении вызова рекурсивной функции предыдущие значения параметров вытягиваются из стека, что приводит к лишним операциям. Итерационный алгоритм для такой же задачи работает быстрее;
- для рекурсивного процесса нужно больше памяти чем для итерации. Это связано с тем, что при рекурсивном вызове нужно сохранять предыдущее значение внутренних переменных вызывающей функции, чтобы по завершении рекурсивного вызова восстановить ее выполнение. Таким образом, если рекурсивная функция вызывается много раз, то это может привести к чрезмерно большому использованию памяти.