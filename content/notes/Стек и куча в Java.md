---
aliases: heap, stack
tags: Java/ПодКапотом
---
## Stack память в Java

Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.  
Размер стековой памяти намного меньше объема памяти в куче.

>[!tip] В стеке хранятся ссылки и примитивы

## Java Heap память

Java Heap (куча) используется `Java Runtime` для выделения памяти под объекты и [JRE](https://javadevblog.com/chto-takoe-jdk-jre-i-jvm-v-java.html) классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем удаления объектов, на которые нет каких-либо ссылок. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться с любой части приложения.

>[!tip] В куче хранятся объекты

## Разница между Stack и Heap памятью в Java

Давайте рассмотрим отличия стековой памяти и кучи на примере простой программы.
```java
public class Memory {

    public static void main(String[] args) { // строка 1
        int i=1; // строка 2
        Object object = new Object(); // строка 3
        Memory memory = new Memory(); // строка 4
        memory.exMethod(object); // строка 5
    } // строка 9

    private void exMethod(Object param) { // строка 6
        String string = param.toString(); // строка 7
        System.out.println(string );
    } // строка 8

}
```
На картинке ниже представлена память стека и кучи для программы выше
![[Стек и куча Img.png]]
А теперь рассмотри шаги выполнения нашей программы:

1. Как только мы запустим программу, загружаются все классы среды выполнения в кучу. Потом  метод `main()`находит `строку 1` и Java Runtime создает стековую память для использования методом main().
2. Далее в `строке 2` создается int’овая переменная, которая хранится в памяти стека метода `main()`.
3. Потом мы создали объект в `строке 3` и он тут же появляется в куче, а стековая память содержит ссылку на него. Точно такой же процесс происходит, когда мы создаем объект Memory в `строке 4`.
4. Теперь в `строке 5` мы вызываем метод `exMethod()` и тут же сразу создается блок на вершине стека, который будет использоваться этим методом. Поскольку в Java объекты и примитивы передаются по значению, то в `строке 6` будет создана новая ссылка на объект, созданный в строке 3.
5. Строка, созданная в `строке 7`, отправляется в [Пул строк (String Pool)](https://javadevblog.com/chto-takoe-pul-strok-v-java.html), который находится в куче. На эту строку также создается ссылка в стековой памяти метода `exMethod()`.
6. Метод `exMethod()`завершается на `строке 8`, поэтому блок стековой памяти для этого метода становится свободным.
7. В `строке 9` метод `main()` завершается, поэтому стековая память для метода `main()` будет уничтожена. Также программа заканчивается в этой строке, следовательно, Java Runtime освобождает всю память и завершает программу.

**На основании приведенных выше объяснений, мы можем легко подытожить следующие различия между Heap и Stack памятью в Java:**
- Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.
- Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
- Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
- Управление памятью в стеке осуществляется по схеме `LIFO`.
- Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
- Мы можем использовать `-Xms` и `-Xmx` опции [JVM](https://javadevblog.com/chto-takoe-jdk-jre-i-jvm-v-java.html), чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции `-Xss` .
- Если память стека полностью занята, то Java Runtime бросает `java.lang.StackOverflowError`, а если память кучи заполнена, то бросается [исключение](https://javadevblog.com/polnoe-rukovodstvo-po-obrabotke-isklyuchenij-v-java.html) `java.lang.OutOfMemoryError: Java Heap Space`.
- Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (`LIFO`), стековая память работает намного быстрее кучи.

## Литература: 
- Про stack и heap память в Java [Что такое Heap и Stack память в Java? — Программирование на Java, Android](https://javadevblog.com/chto-takoe-heap-i-stack-pamyat-v-java.html#:~:text=%D0%A0%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20Stack%20%D0%B8%20Heap%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E%20%D0%B2%20Java&text=%D0%9A%D1%83%D1%87%D0%B0%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F%20%D0%B2%D1%81%D0%B5%D0%BC%D0%B8%20%D1%87%D0%B0%D1%81%D1%82%D1%8F%D0%BC%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F,%D1%81%D1%82%D0%B5%D0%BA%D0%B0%20%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D1%82%D1%81%D1%8F%20%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0%20%D0%BD%D0%B0%20%D0%BD%D0%B5%D0%B3%D0%BE.)
